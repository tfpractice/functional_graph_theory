{"version":3,"file":"bundle.umd.js","sources":["../src/components.js","../src/reducers.js","../src/graph.js","../src/contract.js","../src/path.js","../src/search.js","../src/show.js"],"sourcesContent":["import { addBinMap, addSet, diff, spreadK, spreadV, tuple, }\n from 'fenugreek-collections';\n\n // **components** `::  Map<edge> -> Map<component>`\n // maps each node to a set of connected nodes\nexport const components = (edges) => {\n  const trav = (comp = new Set, node) =>\n     diff(spreadK(edges.get(node)))(comp).reduce(trav, addSet(comp)(node));\n     \n  const visitMap = (mMap = new Map, node) =>\n     diff(trav(new Set, node))(mMap).map(tuple(trav(new Set, node)))\n       .reduce(addBinMap, mMap);\n  \n  return spreadK(edges).reduce(visitMap, new Map);\n};\n\n// **componentSet** `::  Map<edge> -> Set<component>`\n// partitions an edgelist into sets of connected nodes\nexport const componentSet = edges => new Set(spreadV(components(edges)));\n","import { addBinMap, addMap, append, asMap, flatTuple,\n  get, mapDiff, removeMap, spread, spreadK, } from 'fenugreek-collections';\n\n// **resetNodeBin** `:: ( Map<edge>, node ) -> Map<edge>`\n// resets the nodes adjacency list to an empty map\nexport const resetNodeBin = (edges, src) => addMap(edges)(src)(asMap());\n\n// **addNodeBin** `:: ( Map<edge>, node ) -> Map<edge>`\n// adds a node:adjacency list pair to an edgelist\nexport const addNodeBin = (edges, src) => addMap(edges)(src)(asMap(get(edges)(src)));\n\n// **neighborPairs** `:: ( Map<edge>, node ) -> [ [node, node] ]`\n// returns an array of [node, neigbor] pairs from an edgelist\nexport const neighborPairs = edges => src =>\n  spreadK(get(edges)(src)).map(append(src));\n\n// **addEdgeBin** `:: ( Map<edge>, [node, node, Number] ) -> Map<edge>`\n// add a node:Map<{node: Number}> entry to an edgelist\nexport const addEdgeBin = (edges, [ src, nb, wt = 0 ]) => [\n  [ src, addMap(get(edges)(src))(nb)(wt) ],\n  [ nb, addMap(get(edges)(nb))(src)(wt) ],].reduce(addBinMap, asMap(edges));\n\n// **removeEdgeBin** `:: ( Map<edge>, [node, node] ) -> Map<edge>`\n// removes a {node:Map<{node: Number}>} entry from an edgelist\nexport const removeEdgeBin = (edges, [ src, nb, ]) => [\n  [ src, removeMap(get(edges)(src))(nb) ],\n  [ nb, removeMap(get(edges)(nb))(src) ]].reduce(addBinMap, asMap(edges));\n\n// **disconnectNodeBin** `:: ( Map<edge>, node ) -> Map<edge>`\n// removes all edges connected to a node\nexport const disconnectNodeBin = (edges, src) =>\n  neighborPairs(edges)(src).reduce(removeEdgeBin, asMap(edges));\n\n// **removeNodeBin** `:: ( Map<edge>, node ) -> Map<edge>`\n// isolates a node and removes it from edgelist\nexport const removeNodeBin = (edges, src) =>\n  removeMap(disconnectNodeBin(edges, src))(src);\n\n// **importEdgeBin** `:: ( Map<edge>, [node, [node: Number]] ) -> Map<edge>`\n// appends a node and all of its neighbors to an edgelist\nexport const importEdgeBin = (edges, [ src, nbs ]) =>\nspread(mapDiff(nbs)(get(edges)(src))).map(flatTuple(src))\n  .reduce(addEdgeBin, addNodeBin(edges, src));\n\n// **mergeEdgesBin** `:: ( Map<edge>, Map<edge>, ) -> Map<edge>`\n// combines two Edge maps\nexport const mergeEdgesBin = (edges, alts) =>\n spread(asMap(alts)).reduce(importEdgeBin, edges);\n","import { addBinMap, asMap, get, hasK, removeBin, spreadK, triple, tuple, uniteMap, } from 'fenugreek-collections';\nimport { addEdgeBin, addNodeBin, disconnectNodeBin, mergeEdgesBin, removeEdgeBin, resetNodeBin, }\nfrom './reducers';\n\n// **mergeNeighbors** `::  Map<edge> ->  node  -> Map<edge>`\n// resets the nodes adjacency list to an empty map\nexport const mergeNeighbors = uniteMap;\n\n// **graph** `:: [Node] -> Map<edge>`\n// adds  {node: adjacencyList} pairs ot an Edgelist\nexport const graph = (...elems) => elems.reduce(addNodeBin, new Map);\n\n// **nodes** `::  Map<edge> ->  [node]\n// returns an array of the nodes\nexport const nodes = edges => spreadK(asMap(edges));\n\n// **copy** `::  Map<edge> -> Map<edge>`\n// creates a copy of a Edgelist\nexport const copy = edges => nodes(edges).reduce(addNodeBin, asMap(edges));\n\n// **adj** `::  Map<edge> ->  node  -> Map<{node: Number}>`\n// returns the nodes adjacency list\nexport const adj = edges => src => asMap(get(edges)(src));\n\n// **neighbors** `::  Map<edge> ->  node  -> [node]`\n// returns the nodes neighbors\nexport const neighbors = edges => src => nodes(adj(edges)(src));\n\n// **contains** `::  Map<edge> ->  node  -> Boolean`\n// checks for the presence of a node in an edgelist\nexport const contains = edges => node => hasK(edges)(node);\n\n// **isAdjacent** `::  Map<edge> ->  node  -> Map<edge>`\n// checks for the presence of a neighbor in a node's adjacency list\nexport const isAdjacent = edges => src => nb => contains(adj(edges)(src))(nb);\n\n// **addNodes** `::  Map<edge> ->  ...node  -> Map<edge>`\n// adds nodes to an Edgelist\nexport const addNodes = edges => (...srcs) => srcs.reduce(addNodeBin, edges);\n\n// **resetNodes** `::  Map<edge> ->  ...node  -> Map<edge>`\n// resets the adjacency lists of given nodes to an empty map\nexport const resetNodes = edges => (...src) => src.reduce(resetNodeBin, edges);\n\n// **addEdges** `::  Map<edge> ->  (node, Number) -> ...node  -> Map<edge>`\n// creates edges between a node and multiple other nodes\nexport const addEdges = edges => (src, w = 0) => (...nabes) =>\nnabes.map(triple(w)(src)).reduce(addEdgeBin, edges);\n\n// **removeEdges** `::  Map<edge> ->  node -> ...node  -> Map<edge>`\n// removes edges between a node and select other nodes\nexport const removeEdges = edges => src => (...nabes) =>\nnabes.map(tuple(src)).reduce(removeEdgeBin, edges);\n\n// **disconnectNodes** `:: Map<edge> ->  ...node  -> Map<edge>`\n// resets the nodes adjacency list to an empty map\nexport const disconnectNodes = edges => (...srcs) =>\n srcs.reduce(disconnectNodeBin, copy(edges));\n\n // **removeNodes** `::  Map<edge> ->  ...node  -> Map<edge>`\n // resets the nodes adjacency list to an empty map\nexport const removeNodes = edges => (...srcs) =>\nsrcs.reduce(removeBin, disconnectNodes(edges)(...srcs));\n\n// **mergeEdges** `::  Map<edge> -> ...{node:adjacency} -> Map<edge>`\n// resets the nodes adjacency list to an empty map\nexport const mergeEdges = edges => (...alt) => alt.reduce(mergeEdgesBin, edges);\n\n// **addNeighbor** `::  Map<edge> -> ...{node:adjacency} -> Map<edge>`\n// resets the nodes adjacency list to an empty map\nexport const addNeighbor = edges => src => (n, w = 0) =>\naddBinMap(adj(edges)(src), [ n, w ]);\n\n// **addEntry** `::  Map<{node:Number}> ->  [node, Number]  -> Map<edge>`\n// resets the nodes adjacency list to an empty map\nexport const addEntry = nabes => ([ n, w = 0 ]) => addBinMap(nabes, [ n, w ]);\n","import { addMap, asMap, asSet, first, flatten, flattenBin, isIterable,\n   removeBin, spread, } from 'fenugreek-collections';\nimport { adj, copy, mergeEdges, neighbors, nodes, removeNodes, } from './graph';\nimport * as reducers from './reducers';\n\nexport const autoSpread = el =>\nisIterable(el) ? (spread(el).reduce(flattenBin, []).map(autoSpread)) : el;\n\nexport const superNode = src => nb => asSet([ src, nb ]);\n\nexport const combineNeighbors = g => src => nb =>\n  asSet(flatten(neighbors(g)(src))(neighbors(g)(nb)));\n\nexport const combineAdj = g => src => nb =>\n  asMap(flatten(adj(g)(src))(adj(g)(nb)));\n\nexport const superAdj = g => src => nb =>\n [ src, nb ].reduce(removeBin, combineAdj(g)(src)(nb));\n\nexport const superEdge = g => src => nb =>\n  addMap()(superNode(src)(nb))(superAdj(g)(src)(nb));\n\nexport const contract = g => src => (nb = first(neighbors(g)(src))) =>\nnb ? mergeEdges(removeNodes(g)(src, nb))(superEdge(g)(src)(nb)) : g;\n\nexport const contractBin = (g, [ src, nb ]) => contract(g)(src)(nb);\n\nexport const contractSrc = g => src =>\nreducers.neighborPairs(g)(src).reduce(contractBin, copy(g));\n\nexport const contractNext = (g, n = (first(nodes(g)))) =>\n  contract(copy(g))(n)();\n\nexport const contractAuto = g => nodes(g).reduce(contractNext, g);\nexport const contractMin = (g, min = 2) =>\n g.size > min ? contractMin(contractNext(g), min) : copy(g);\n","import { addMap, lastK, } from 'fenugreek-collections';\n\n// **pathEntry** `:: ( node, Number, Number ) -> {pred, length, weight}`\n// returns an object with pred, weight, and length properties\nexport const pathEntry = (pred = null, length = 1, weight = 0) => ({ pred, length, weight });\nconst pathVal = (pred = null) => (length = 1) => (weight = 0) =>\n  ({ pred, length, weight });\n  \n// **addSrc** `:: Map<pathEntry> -> node ->  Map<pathEntry>`\n// adds a {node:{pred, weight, length}} entry to a  path\nexport const appendPath = path => src => addMap(path)(src)(pathEntry(lastK(path), 1, 0));\n\n// **initPath** `:: node -> Map<pathEntry>`\n// initializes a new path given a source node\nexport const initPath = node => appendPath()(node);\n\n// **getWeight** `:: {weight:Number} -> Number`\n// returns an object with pred, weight, and length properties\nexport const getWeight = ({ weight = 0 }) => weight;\n\n// **getLength** `:: {length:Number} -> Number`\n// returns an object with pred, weight, and length properties\nexport const getLength = ({ length = 1 }) => length;\n\n// **lastVal** `:: Map<pathEntry> -> {pred, length, weight}`\n// returns the last entry in the path\nexport const lastVal = path => path.get(lastK(path));\n\n// **lastWeight** `:: Map<pathEntry> -> Number`\n// returns the last weight in the path\nexport const lastWeight = path => getWeight(lastVal(path));\n\n// **lastLength** `:: Map<pathEntry> -> Number`\n// returns the last length in the path\nexport const lastLength = path => getLength(lastVal(path));\n\n// **nextWeight** `:: Map<pathEntry> -> Number -> Number`\n// returns an object with pred, weight, and length properties\nexport const nextWeight = path => (w = 0) => lastWeight(path) + w;\n\n// **nextLength** `:: Map<pathEntry> -> Number -> Number`\n// returns an object with pred, weight, and length properties\nexport const nextLength = path => lastLength(path) ? lastLength(path) + 1 : 1;\n\n// **nextPath** `:: (Map<pathEntry>, [node, Number]) -> Map<pathEntry> `\n// returns an object with pred, weight, and length properties\nexport const nextPath = (path = new Map, [ n, w = 0 ]) =>\n  path.set(n, pathVal(lastK(path))(nextLength(path))(nextWeight(path)(w)));\n","import { addBinSet, asSet, get, hasK, lastK, mapDiff, popFirst, spread, spreadK, } from 'fenugreek-collections';\nimport { initPath, nextPath, } from './path';\nimport { components, } from './components';\n\n// **dfs** `:: Map<edge> -> node -> Map<pathEntry>`\n// depth first traversal\nexport const dfs = edges => (src) => {\n  // >**dfs.trav** `:: Map<pathEntry> -> [node, w] -> Map<pathEntry>`\n  // >depth first traversal\n  const trav = (path = initPath(src), [ n, w ] = [ lastK(path), 0 ]) =>\n    spread(mapDiff(edges.get(n))(path)).reduce(trav, nextPath(path, [ n, w ]));\n  \n  return trav(initPath(src));\n};\n\n// **bfs** `:: Map<edge> -> node -> Map<pathEntry>`\n// breadth first traversal\nexport const bfs = edges => (iNode) => {\n  const bVisit = bPath => (bQueue) => {\n    const pred = popFirst(bQueue);\n    const nextNabes = mapDiff(edges.get(pred))(bPath);\n    \n    spread(nextNabes).reduce(nextPath, bPath);\n    spreadK(nextNabes).reduce(addBinSet, bQueue);\n    return bQueue.size > 0 ? bVisit(bPath)(bQueue) : bPath;\n  };\n  \n  return bVisit(initPath(iNode))(asSet([ iNode ]));\n};\n\n// **dijkstra** `:: Map<edge> -> node -> Map<pathEntry>`\n// finds shortest paths from a source node to all node reachable from that node\nexport const dijkstra = edges => (iNode) => {\n  const reachables = bfs(edges)(iNode);\n  const inspectQueue = asSet([ iNode ]);\n  const solutionSet = initPath(iNode);\n  \n  while (inspectQueue.size > 0) {\n    const pred = popFirst(inspectQueue);\n    const nextNabes = edges.get(pred);\n    const { length: dCount, weight: dWeight } = solutionSet.get(pred);\n    \n    for (const [ nabe, nWeight ] of nextNabes) {\n      const prevMap = reachables.get(nabe) || { length: 1, weight: 0 };\n      const { length: rCount, weight: rWeight } = prevMap;\n      const dMap = { pred, length: dCount + 1, weight: dWeight + nWeight, };\n      const sMap = ((dWeight + nWeight) < rWeight) ? dMap : prevMap;\n      \n      if (!solutionSet.has(nabe)) {\n        inspectQueue.add(nabe);\n        solutionSet.set(nabe, sMap);\n      }\n    }\n  }\n  return solutionSet;\n};\n\n// **pathBetween** `:: Map<edge> -> node -> node -> Boolean`\n// checks for a path between two nodes\nexport const pathBetween = e => n0 => n1 => hasK(get(components(e))(n0))(n1);\n","import { last, spread, spreadK, spreadKV, spreadV, } from 'fenugreek-collections';\n\nexport const redStr = (str = ' ', val, id, coll) =>\n  val === last(coll) ? str.concat(val, ' ') : str.concat(val, ' , ');\nexport const collString = coll => spread(coll).reduce(redStr, '');\nexport const kString = coll => spreadK(coll).reduce(redStr, '');\nexport const vString = coll => spreadV(coll).reduce(redStr, '');\nexport const kvString = coll => spreadKV(coll).reduce(redStr, '');\n\nexport const pathString = path => ` { ${spreadK(path).join(' => ')} }`;\nexport const edgeString = ([src, nbs]) => `{ Edge ${src} >> [ ${kString(nbs)} ] } `;\n\nexport const componentString = ([node, nbs]) =>\n  `{ component ${node} >> [ ${kString(nbs)} ] } `;\n\nexport const graphString = edges =>\n  spreadKV(edges).reduce((str, [node, nabes], id) =>\n    str + edgeString([node, nabes]),\n    'Showing Edges\\n');\n\nexport const showGraph = ({ edges }) => (graphString(edges));\n"],"names":["components","edges","trav","comp","Set","node","diff","spreadK","get","reduce","addSet","visitMap","mMap","Map","map","tuple","addBinMap","componentSet","spreadV","resetNodeBin","src","addMap","asMap","addNodeBin","neighborPairs","append","addEdgeBin","nb","wt","removeEdgeBin","removeMap","disconnectNodeBin","importEdgeBin","nbs","spread","mapDiff","flatTuple","mergeEdgesBin","alts","mergeNeighbors","uniteMap","graph","elems","nodes","copy","adj","neighbors","contains","hasK","isAdjacent","addNodes","srcs","resetNodes","addEdges","w","nabes","triple","removeEdges","disconnectNodes","removeNodes","removeBin","mergeEdges","alt","addNeighbor","n","addEntry","autoSpread","isIterable","el","flattenBin","superNode","asSet","combineNeighbors","flatten","g","combineAdj","superAdj","superEdge","contract","first","contractBin","contractSrc","reducers","contractNext","contractAuto","contractMin","min","size","pathEntry","pred","length","weight","pathVal","appendPath","path","lastK","initPath","getWeight","getLength","lastVal","lastWeight","lastLength","nextWeight","nextLength","nextPath","set","dfs","bfs","iNode","bVisit","bQueue","popFirst","nextNabes","bPath","addBinSet","dijkstra","reachables","inspectQueue","solutionSet","dCount","dWeight","nabe","nWeight","prevMap","rWeight","dMap","sMap","has","add","pathBetween","e","n0","n1","redStr","str","val","coll","last","concat","collString","kString","vString","kvString","spreadKV","pathString","join","edgeString","componentString","graphString","id","showGraph"],"mappings":"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"}