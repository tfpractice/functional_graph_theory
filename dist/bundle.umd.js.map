{"version":3,"file":null,"sources":["../src/reducers.js","../src/graph.js","../src/traversals.js","../src/index.js"],"sourcesContent":["import { collections, } from 'turmeric';\n\nconst { spread, tuple, addMap, get, spreadK, flatTuple, } = collections;\nconst { uniteMap, mapDiff, mapUnion, diff } = collections;\nconst { asMap, addBinMap, removeBinTuple, removeMap, removeBin } = collections;\n\nexport const set = m => k => v => new Map(m).set(k, v);\n\nexport const nabeMap = edges => src => new Map(get(edges)(src));\nexport const nabes = (edges = new Map) => src => spreadK(nabeMap(edges)(src));\nexport const addSrc = (edges, src) => addMap(edges)(src)(nabeMap(edges)(src));\n\nexport const addEdgeBin = (edges = new Map, [ src, nb, wt = 0 ]) =>\n   edges\n     .set(src, addMap(nabeMap(edges)(src))(nb)(wt))\n     .set(nb, addMap(nabeMap(edges)(nb))(src)(wt));\n\nexport const rmEdgeBin = (edges = new Map, [ src, nb, wt = 0 ]) => edges\n  .set(src, removeMap(edges.get(src))(nb))\n  .set(nb, removeMap(edges.get(src))(src));\n\nexport const clearNeighborsBin = (edges = new Map, src) =>\n  edges.set(src, new Map);\n\nexport const importEdgeBin = (edges = new Map, [ src, nbs ] = [ , new Map ]) =>\n   spread(mapDiff(nbs)(edges.get(src))).map(flatTuple(src)).reduce(addEdgeBin, addSrc(edges, src));\n","import { collections, } from 'turmeric';\nimport { addEdgeBin, addSrc, clearNeighborsBin, importEdgeBin, rmEdgeBin, } from './reducers';\nconst { spread, spreadKV, tuple, triple, addMap, get, spreadK, flatTuple, hasK, } = collections;\nconst { uniteMap, mapDiff, mapUnion, diff } = collections;\nconst { asMap, addBinMap, removeBinTuple, removeMap, removeBin } = collections;\n\nexport const spawn = edges => new Map(edges);\nexport const copy = spawn;\nexport const fromElements = (...elements) => elements.reduce(addSrc, spawn());\nexport const nodes = edges => spreadK(asMap(edges));\nexport const adj = edges => src => edges.get(src) || new Map;\n\nexport const neighbors = edges => src => nodes(adj(edges)(src));\n\nexport const contains = edges => node => hasK(edges)(node);\n\nexport const isAdjacent = edges => src => nabe =>\n  contains(adj(edges)(src))(nabe);\n\nexport const addNodes = edges => (...srcs) => srcs.reduce(addSrc, edges);\n\nexport const removeNodes = edges => (...nodes) =>\n  nodes.reduce(removeBin, edges);\n\nexport const addEdges = edges => (src, w = 0) => (...nabes) =>\n  nabes.map(triple(w)(src)).reduce(addEdgeBin, edges);\n\nexport const removeEdges = edges => src => (...nabes) =>\n  nabes.map(triple(0)(src)).reduce(rmEdgeBin, edges);\n\nexport const mergeEdges = (edges = new Map) => (altEdges = new Map) => {\n  const rval = spread(altEdges).reduce(importEdgeBin, edges);\n\n  console.log('uniteMapedges(altEdges)', uniteMap(edges)(altEdges));\n\n  console.log('rval', new Map(rval));\n  return new Map(spreadKV(altEdges).reduce(importEdgeBin, edges));\n};\n\nexport const addNeighbor = edges => src => (n, w = 0) =>\n  addBinMap(adj(edges)(src), [ n, w ]);\nexport const addEntry = nabes => ([ n, w = 0 ]) => addBinMap(nabes, [ n, w ]);\n\nexport const clearNeighbors = (edges = new Map) => (...nodes) =>\n  nodes.reduce(clearNeighborsBin, edges);\n\n//\n// export const clearEdges = (edges) => edges.clear;\n//\nexport const mergeNeighbors = uniteMap;\n\n// module.exports = {\n// \tspawn,\n// \tcontains,\n// \tnodes,\n// \tadj,\n// \tcopy,\n// \tisAdjacent,\n// \taddNodes,\n// \tremoveEdges,\n// \tremoveNodes,\n// \tneighbors,\n// \taddNeighbor,\n// \taddEdges,\n// \taddEdgeR,\n// \taddEntry,\n// \tclearNeighbors,\n// \tmergeNeighbors,\n// \tmergeEdges,\n// \tfromElements,\n// };\n","const Utils = require('./utils');\n\n// const { Commands: { spread, spreadK, spreadV, spreadKV, popFirst }} = Utils;\n// const { Commands: { tuple, flatTuple, triple, addMap, addSet }} = Utils;\n// const { Queries: { lastK, hasK, x_hasK, hasKV, x_hasKV }} = Utils;\nconst { Strings: { componentString }} = Utils;\n\n// const { Comparitors: { diff, mapDiff }} = Utils;\n\nimport { collections, } from 'turmeric';\nimport { addEdgeBin, clearNeighborsBin, importEdgeBin, rmEdgeBin, } from './reducers';\nconst { addMap, get, addSet } = collections;\nconst { lastK, hasK, x_hasK, hasKV, x_hasKV } = collections;\nconst { uniteMap, mapDiff, mapUnion, diff } = collections;\nconst { asMap, addBinMap, removeBinTuple, removeMap, removeBin } = collections;\nconst { spread, spreadK, spreadKV, popFirst, tuple, flatTuple, triple, } = collections;\n\nconst pathVal = (pred = null) => (length = 1) => (weight = 0) =>\n  ({ pred, length, weight });\n\nconst addSrc = (path = new Map) => src =>\n  path.set(src, { pred: lastK(path), weight: 0, length: 1 });\n\nconst initPath = node => addSrc()(node);\nconst ptW = ({ weight = 0 }) => weight;\nconst ptL = ({ length = 1 }) => length;\nconst lastVal = path => path.get(lastK(path));\nconst lastW = path => ptW(lastVal(path));\nconst lastL = path => ptL(lastVal(path));\nconst nextW = path => (w = 0) => lastW(path) + w;\nconst nextL = path => lastL(path) ? lastL(path) + 1 : 1;\n\nconst nextPath = (path = new Map, [ n, w = 0 ]) =>\n  path.set(n, pathVal(lastK(path))(nextL(path))(nextW(path)(w)));\n\nconst dfs = edges => (src) => {\n  const trav = (path = initPath(src), [ n, w ] = [ lastK(path), 0 ]) =>\n    spread(mapDiff(edges.get(n))(path)).reduce(trav, nextPath(path, [ n, w ]));\n\n  return trav(initPath(src));\n};\n\nconst bfs = edges => (iNode) => {\n  const bVisit = bPath => (bQueue) => {\n    const pred = popFirst(bQueue);\n    const nextNabes = mapDiff(edges.get(pred))(bPath);\n\n    spread(nextNabes).reduce(nextPath, bPath);\n    spreadK(nextNabes).reduce(addSet, bQueue);\n    return bQueue.size > 0 ? bVisit(bPath)(bQueue) : bPath;\n  };\n\n  return bVisit(initPath(iNode))(new Set([ iNode ]));\n};\n\nconst dijkstra = edges => (iNode) => {\n  const reachables = bfs(edges)(iNode);\n  const inspectQueue = new Set([ iNode ]);\n  const solutionSet = initPath(iNode);\n\n  while (inspectQueue.size > 0) {\n    const pred = popFirst(inspectQueue);\n    const nextNabes = edges.get(pred);\n    let { length: dCount, weight: dWeight } = solutionSet.get(pred);\n\n    for (let [ nabe, nWeight ] of nextNabes) {\n      const prevMap = reachables.get(nabe);\n      let { length: rCount, weight: rWeight } = prevMap;\n      const dMap = { pred, length: dCount + 1, weight: dWeight + nWeight, };\n      const sMap = ((dWeight + nWeight) < rWeight) ? dMap : prevMap;\n\n      if (!solutionSet.has(nabe)) {\n        inspectQueue.add(nabe);\n        solutionSet.set(nabe, sMap);\n      }\n    }\n  }\n\n  return solutionSet;\n};\n\nconst components = (edges) => {\n  const trav = (comp = new Set, node) =>\n    diff(spreadK(edges.get(node)))(comp).reduce(trav, comp.add(node));\n\n  const visitMap = (mMap = new Map, node) =>\n    diff(trav(new Set, node))(mMap)\n      .map(tuple(trav(new Set, node)))\n      .reduce(addMap, mMap);\n\n  return spreadK(edges).reduce(visitMap, new Map);\n};\n\nconst componentSet = edges => new Set(spreadV(components(edges)));\nconst pathBetween = edges => n0 => n1 =>\n  hasK(components(edges).get(n1))(n0);\n\nmodule.exports = {\n  dfs,\n  bfs,\n  dijkstra,\n  components,\n  componentSet,\n  pathBetween,\n};\n","import * as Reducers from './reducers';\nimport * as Graph from './graph';\nimport * as Traversals from './traversals';\n\nexport { Graph, Reducers, Traversals, };\n\n// exports.Graph = require('./graph');\n\n// exports.Reducers = require('./reducers');\nexports.Utils = require('./utils');\nexports.AsyncOps = require('./async_operators');\n\n// exports.Traversals = require('./traversals');\n"],"names":["spread","collections","addMap","get","spreadK","flatTuple","mapDiff","removeMap","set","Map","m","k","v","nabeMap","edges","src","nabes","addSrc","addEdgeBin","nb","wt","rmEdgeBin","clearNeighborsBin","importEdgeBin","nbs","map","reduce","spreadKV","tuple","triple","hasK","uniteMap","asMap","addBinMap","removeBinTuple","removeBin","spawn","copy","fromElements","elements","nodes","adj","neighbors","contains","node","isAdjacent","nabe","addNodes","srcs","removeNodes","addEdges","w","removeEdges","mergeEdges","altEdges","rval","log","addNeighbor","n","addEntry","clearNeighbors","mergeNeighbors","require","addSet","lastK","mapUnion","diff","popFirst","pathVal","pred","length","weight","path","initPath","ptW","ptL","lastVal","lastW","lastL","nextW","nextL","nextPath","dfs","trav","bfs","iNode","bVisit","bQueue","nextNabes","bPath","size","Set","dijkstra","reachables","inspectQueue","solutionSet","dCount","dWeight","nWeight","prevMap","rWeight","dMap","sMap","has","add","components","comp","visitMap","mMap","componentSet","spreadV","pathBetween","n1","n0","module","exports","Utils","AsyncOps"],"mappings":"sqBAEQA,EAAoDC,cAApDD,OAAoDC,EAAAA,cAArCC,OAAQC,EAA6BF,cAA7BE,IAAKC,EAAwBH,cAAxBG,QAASC,EAAeJ,cAAfI,UACCJ,EAAAA,cAA5BK,QACiDL,EAAAA,cAAzBM,UAE7BC,EAAM,kBAAK,mBAAK,mBAAK,IAAIC,KAAIC,GAAGF,IAAIG,EAAGC,MAEvCC,EAAU,kBAAS,mBAAO,IAAIJ,KAAIN,EAAIW,GAAOC,MAC7CC,EAAQ,cAACF,0DAAQ,GAAIL,WAAQ,mBAAOL,GAAQS,EAAQC,GAAOC,MAC3DE,EAAS,SAACH,EAAOC,SAAQb,GAAOY,GAAOC,GAAKF,EAAQC,GAAOC,KAE3DG,EAAa,cAACJ,0DAAQ,GAAIL,6BAAOM,OAAKI,cAAIC,aAAK,UACzDN,GACGN,IAAIO,EAAKb,EAAOW,EAAQC,GAAOC,IAAMI,GAAIC,IACzCZ,IAAIW,EAAIjB,EAAOW,EAAQC,GAAOK,IAAKJ,GAAKK,KAEjCC,EAAY,cAACP,0DAAQ,GAAIL,6BAAOM,OAAKI,kBAAiBL,GAChEN,IAAIO,EAAKR,EAAUO,EAAMX,IAAIY,IAAMI,IACnCX,IAAIW,EAAIZ,EAAUO,EAAMX,IAAIY,IAAMA,KAExBO,EAAoB,cAACR,0DAAQ,GAAIL,KAAKM,qBACjDD,GAAMN,IAAIO,EAAK,GAAIN,OAERc,EAAgB,cAACT,0DAAQ,GAAIL,gEAAwB,GAAIA,eAArBM,OAAKS,aACnDxB,GAAOM,EAAQkB,GAAKV,EAAMX,IAAIY,KAAOU,IAAIpB,EAAUU,IAAMW,OAAOR,EAAYD,EAAOH,EAAOC,4hBCvBrFf,EAA4EC,cAA5ED,OAAQ2B,EAAoE1B,cAApE0B,SAAUC,EAA0D3B,cAAnD4B,OAAQ3B,EAA2CD,cAA9BG,QAASC,EAAqBJ,cAAV6B,KAClEC,EAAsC9B,cAAtC8B,SACAC,EAA2D/B,cAA3D+B,MAAOC,EAAoDhC,cAApDgC,UAAWC,EAAyCjC,cAAdkC,UAExCC,EAAQ,kBAAS,IAAI3B,KAAIK,IACzBuB,EAAOD,EACPE,EAAe,sCAAIC,+CAAaA,GAASb,OAAOT,EAAQmB,MACxDI,EAAQ,kBAASpC,GAAQ4B,EAAMlB,KAC/B2B,EAAM,kBAAS,mBAAO3B,GAAMX,IAAIY,IAAQ,GAAIN,OAE5CiC,EAAY,kBAAS,mBAAOF,GAAMC,EAAI3B,GAAOC,MAE7C4B,EAAW,kBAAS,mBAAQb,GAAKhB,GAAO8B,KAExCC,EAAa,kBAAS,mBAAO,mBACxCF,GAASF,EAAI3B,GAAOC,IAAM+B,MAEfC,EAAW,kBAAS,uCAAIC,+CAASA,GAAKtB,OAAOT,EAAQH,KAErDmC,EAAc,kBAAS,uCAAIT,+CACtCA,GAAMd,OAAOS,EAAWrB,KAEboC,EAAW,kBAAS,UAACnC,MAAKoC,0DAAI,QAAM,uCAAInC,+CACnDA,GAAMS,IAAII,EAAOsB,GAAGpC,IAAMW,OAAOR,EAAYJ,MAElCsC,EAAc,kBAAS,mBAAO,uCAAIpC,+CAC7CA,GAAMS,IAAII,EAAO,GAAGd,IAAMW,OAAOL,EAAWP,MAEjCuC,EAAa,cAACvC,0DAAQ,GAAIL,WAAQ,eAAC6C,0DAAW,GAAI7C,KACvD8C,EAAOvD,EAAOsD,GAAU5B,OAAOH,EAAeT,kBAE5C0C,IAAI,0BAA2BzB,EAASjB,GAAOwC,YAE/CE,IAAI,OAAQ,GAAI/C,KAAI8C,IACrB,GAAI9C,KAAIkB,EAAS2B,GAAU5B,OAAOH,EAAeT,MAG7C2C,EAAc,kBAAS,mBAAO,UAACC,MAAGP,0DAAI,QACjDlB,GAAUQ,EAAI3B,GAAOC,IAAQ2C,EAAGP,OACrBQ,EAAW,kBAAS,0BAAGD,cAAGP,aAAI,UAAQlB,GAAUjB,GAAS0C,EAAGP,MAE5DS,EAAiB,cAAC9C,0DAAQ,GAAIL,WAAQ,uCAAI+B,+CACrDA,GAAMd,OAAOJ,EAAmBR,KAKrB+C,EAAiB9B,qoBCtCtB7B,GAXM4D,QAAQ,WAWU7D,cAAxBC,QAAQC,EAAgBF,cAAX8D,OACbC,EAAwC/D,cAAxC+D,MAAOlC,EAAiC7B,cAAjC6B,KACPC,EAAsC9B,cAA5BK,QAAS2D,EAAmBhE,cAATiE,KAE7BlE,EAAmEC,cAAnED,OAAQI,GAA2DH,cAA3DG,QAASuB,GAAkD1B,cAAxCkE,SAAUvC,GAA8B3B,cAA9B2B,MAEvCwC,GAAU,cAACC,0DAAO,WAAS,eAACC,0DAAS,QAAM,eAACC,0DAAS,SACtDF,OAAMC,SAAQC,aAEbtD,GAAS,cAACuD,0DAAO,GAAI/D,WAAQ,mBACjC+D,GAAKhE,IAAIO,GAAOsD,KAAML,EAAMQ,GAAOD,OAAQ,EAAGD,OAAQ,MAElDG,GAAW,kBAAQxD,MAAS2B,IAC5B8B,GAAM,oBAAGH,OAAAA,aAAS,UAAQA,IAC1BI,GAAM,oBAAGL,OAAAA,aAAS,UAAQA,IAC1BM,GAAU,kBAAQJ,GAAKrE,IAAI6D,EAAMQ,KACjCK,GAAQ,kBAAQH,IAAIE,GAAQJ,KAC5BM,GAAQ,kBAAQH,IAAIC,GAAQJ,KAC5BO,GAAQ,kBAAQ,eAAC5B,0DAAI,QAAM0B,IAAML,GAAQrB,IACzC6B,GAAQ,kBAAQF,IAAMN,GAAQM,GAAMN,GAAQ,EAAI,GAEhDS,GAAW,cAACT,0DAAO,GAAI/D,6BAAOiD,cAAGP,aAAI,UACzCqB,GAAKhE,IAAIkD,EAAGU,GAAQJ,EAAMQ,IAAOQ,GAAMR,IAAOO,GAAMP,GAAMrB,MAEtD+B,GAAM,kBAAS,UAACnE,MACdoE,GAAO,QAAPA,QAAQX,0DAAOC,GAAS1D,6DAAmBiD,EAAMQ,GAAO,YAAxBd,OAAGP,aACvCnD,GAAOM,EAAQQ,EAAMX,IAAIuD,IAAIc,IAAO9C,OAAOyD,EAAMF,GAAST,GAAQd,EAAGP,YAEhEgC,GAAKV,GAAS1D,MAGjBqE,GAAM,kBAAS,UAACC,MACdC,GAAS,QAATA,YAAkB,UAACC,MACjBlB,GAAOF,GAASoB,GAChBC,EAAYlF,EAAQQ,EAAMX,IAAIkE,IAAOoB,YAEpCD,GAAW9D,OAAOuD,GAAUQ,MAC3BD,GAAW9D,OAAOqC,EAAQwB,GAC3BA,EAAOG,KAAO,EAAIJ,EAAOG,GAAOF,GAAUE,UAG5CH,GAAOb,GAASY,IAAQ,GAAIM,MAAMN,OAGrCO,GAAW,kBAAS,UAACP,UACnBQ,GAAaT,GAAItE,GAAOuE,GACxBS,EAAe,GAAIH,MAAMN,IACzBU,EAActB,GAASY,GAEtBS,EAAaJ,KAAO,GAAG,IACtBrB,GAAOF,GAAS2B,GAChBN,EAAY1E,EAAMX,IAAIkE,KACc0B,EAAY5F,IAAIkE,GAA5C2B,IAAR1B,OAAwB2B,IAAR1B,0CAEQiB,iDAAW,oBAA9B1C,OAAMoD,OACTC,EAAUN,EAAW1F,IAAI2C,GACDsD,GAAYD,EAApC7B,OAAoC6B,EAApB5B,QAChB8B,GAAShC,OAAMC,OAAQ0B,EAAS,EAAGzB,OAAQ0B,EAAUC,GACrDI,EAASL,EAAUC,EAAWE,EAAWC,EAAOF,CAEjDJ,GAAYQ,IAAIzD,OACN0D,IAAI1D,KACLtC,IAAIsC,EAAMwD,yFAKrBP,KAGHU,GAAa,SAAC3F,MACZqE,GAAO,QAAPA,QAAQuB,0DAAO,GAAIf,KAAK/C,qBAC5BsB,GAAK9D,GAAQU,EAAMX,IAAIyC,KAAQ8D,GAAMhF,OAAOyD,EAAMuB,EAAKF,IAAI5D,KAEvD+D,EAAW,cAACC,0DAAO,GAAInG,KAAKmC,qBAChCsB,GAAKiB,EAAK,GAAIQ,KAAK/C,IAAOgE,GACvBnF,IAAIG,GAAMuD,EAAK,GAAIQ,KAAK/C,KACxBlB,OAAOxB,EAAQ0G,UAEbxG,IAAQU,GAAOY,OAAOiF,EAAU,GAAIlG,OAGvCoG,GAAe,kBAAS,IAAIlB,KAAImB,QAAQL,GAAW3F,MACnDiG,GAAc,kBAAS,mBAAM,mBACjCjF,GAAK2E,GAAW3F,GAAOX,IAAI6G,IAAKC,KAElCC,QAAOC,yGCxFPA,SAAQC,MAAQtD,QAAQ,WACxBqD,QAAQE,SAAWvD,QAAQ"}