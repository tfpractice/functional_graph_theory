{"version":3,"file":"bundle.cjs.js","sources":["../src/components.js","../src/reducers.js","../src/graph.js","../src/contract.js","../src/path.js","../src/search.js","../src/show.js"],"sourcesContent":["import { addBinMap, addSet, diff, spreadK, spreadV, tuple, }\n from 'fenugreek-collections';\n\n // **components** `::  Map<edge> -> Map<component>`\n // maps each node to a set of connected nodes\nexport const components = (edges) => {\n  const trav = (comp = new Set, node) =>\n     diff(spreadK(edges.get(node)))(comp).reduce(trav, addSet(comp)(node));\n     \n  const visitMap = (mMap = new Map, node) =>\n     diff(trav(new Set, node))(mMap).map(tuple(trav(new Set, node)))\n       .reduce(addBinMap, mMap);\n  \n  return spreadK(edges).reduce(visitMap, new Map);\n};\n\n// **componentSet** `::  Map<edge> -> Set<component>`\n// partitions an edgelist into sets of connected nodes\nexport const componentSet = edges => new Set(spreadV(components(edges)));\n","import { addBinMap, addMap, append, asMap, flatTuple,\n  get, mapDiff, removeMap, spread, spreadK, } from 'fenugreek-collections';\n\n// **resetNodeBin** `:: ( Map<edge>, node ) -> Map<edge>`\n// resets the nodes adjacency list to an empty map\nexport const resetNodeBin = (edges, src) => addMap(edges)(src)(asMap());\n\n// **addNodeBin** `:: ( Map<edge>, node ) -> Map<edge>`\n// adds a node:adjacency list pair to an edgelist\nexport const addNodeBin = (edges, src) => addMap(edges)(src)(asMap(get(edges)(src)));\n\n// **neighborPairs** `:: ( Map<edge>, node ) -> [ [node, node] ]`\n// returns an array of [node, neigbor] pairs from an edgelist\nexport const neighborPairs = edges => src =>\n  spreadK(get(edges)(src)).map(append(src));\n\n// **addEdgeBin** `:: ( Map<edge>, [node, node, Number] ) -> Map<edge>`\n// add a node:Map<{node: Number}> entry to an edgelist\nexport const addEdgeBin = (edges, [ src, nb, wt = 0 ]) => [\n  [ src, addMap(get(edges)(src))(nb)(wt) ],\n  [ nb, addMap(get(edges)(nb))(src)(wt) ],].reduce(addBinMap, asMap(edges));\n\n// **removeEdgeBin** `:: ( Map<edge>, [node, node] ) -> Map<edge>`\n// removes a {node:Map<{node: Number}>} entry from an edgelist\nexport const removeEdgeBin = (edges, [ src, nb, ]) => [\n  [ src, removeMap(get(edges)(src))(nb) ],\n  [ nb, removeMap(get(edges)(nb))(src) ]].reduce(addBinMap, asMap(edges));\n\n// **disconnectNodeBin** `:: ( Map<edge>, node ) -> Map<edge>`\n// removes all edges connected to a node\nexport const disconnectNodeBin = (edges, src) =>\n  neighborPairs(edges)(src).reduce(removeEdgeBin, asMap(edges));\n\n// **removeNodeBin** `:: ( Map<edge>, node ) -> Map<edge>`\n// isolates a node and removes it from edgelist\nexport const removeNodeBin = (edges, src) =>\n  removeMap(disconnectNodeBin(edges, src))(src);\n\n// **importEdgeBin** `:: ( Map<edge>, [node, [node: Number]] ) -> Map<edge>`\n// appends a node and all of its neighbors to an edgelist\nexport const importEdgeBin = (edges, [ src, nbs ]) =>\nspread(mapDiff(nbs)(get(edges)(src))).map(flatTuple(src))\n  .reduce(addEdgeBin, addNodeBin(edges, src));\n\n// **mergeEdgesBin** `:: ( Map<edge>, Map<edge>, ) -> Map<edge>`\n// combines two Edge maps\nexport const mergeEdgesBin = (edges, alts) =>\n spread(asMap(alts)).reduce(importEdgeBin, edges);\n","import { addBinMap, asMap, get, hasK, removeBin, spreadK, triple, tuple, uniteMap, } from 'fenugreek-collections';\nimport { addEdgeBin, addNodeBin, disconnectNodeBin, mergeEdgesBin, removeEdgeBin, resetNodeBin, }\nfrom './reducers';\n\n// **mergeNeighbors** `::  Map<edge> ->  node  -> Map<edge>`\n// resets the nodes adjacency list to an empty map\nexport const mergeNeighbors = uniteMap;\n\n// **graph** `:: [Node] -> Map<edge>`\n// adds  {node: adjacencyList} pairs ot an Edgelist\nexport const graph = (...elems) => elems.reduce(addNodeBin, new Map);\n\n// **nodes** `::  Map<edge> ->  [node]\n// returns an array of the nodes\nexport const nodes = edges => spreadK(asMap(edges));\n\n// **copy** `::  Map<edge> -> Map<edge>`\n// creates a copy of a Edgelist\nexport const copy = edges => nodes(edges).reduce(addNodeBin, asMap(edges));\n\n// **adj** `::  Map<edge> ->  node  -> Map<{node: Number}>`\n// returns the nodes adjacency list\nexport const adj = edges => src => asMap(get(edges)(src));\n\n// **neighbors** `::  Map<edge> ->  node  -> [node]`\n// returns the nodes neighbors\nexport const neighbors = edges => src => nodes(adj(edges)(src));\n\n// **contains** `::  Map<edge> ->  node  -> Boolean`\n// checks for the presence of a node in an edgelist\nexport const contains = edges => node => hasK(edges)(node);\n\n// **isAdjacent** `::  Map<edge> ->  node  -> Map<edge>`\n// checks for the presence of a neighbor in a node's adjacency list\nexport const isAdjacent = edges => src => nb => contains(adj(edges)(src))(nb);\n\n// **addNodes** `::  Map<edge> ->  ...node  -> Map<edge>`\n// adds nodes to an Edgelist\nexport const addNodes = edges => (...srcs) => srcs.reduce(addNodeBin, edges);\n\n// **resetNodes** `::  Map<edge> ->  ...node  -> Map<edge>`\n// resets the adjacency lists of given nodes to an empty map\nexport const resetNodes = edges => (...src) => src.reduce(resetNodeBin, edges);\n\n// **addEdges** `::  Map<edge> ->  (node, Number) -> ...node  -> Map<edge>`\n// creates edges between a node and multiple other nodes\nexport const addEdges = edges => (src, w = 0) => (...nabes) =>\nnabes.map(triple(w)(src)).reduce(addEdgeBin, edges);\n\n// **removeEdges** `::  Map<edge> ->  node -> ...node  -> Map<edge>`\n// removes edges between a node and select other nodes\nexport const removeEdges = edges => src => (...nabes) =>\nnabes.map(tuple(src)).reduce(removeEdgeBin, edges);\n\n// **disconnectNodes** `:: Map<edge> ->  ...node  -> Map<edge>`\n// resets the nodes adjacency list to an empty map\nexport const disconnectNodes = edges => (...srcs) =>\n srcs.reduce(disconnectNodeBin, copy(edges));\n\n // **removeNodes** `::  Map<edge> ->  ...node  -> Map<edge>`\n // resets the nodes adjacency list to an empty map\nexport const removeNodes = edges => (...srcs) =>\nsrcs.reduce(removeBin, disconnectNodes(edges)(...srcs));\n\n// **mergeEdges** `::  Map<edge> -> ...{node:adjacency} -> Map<edge>`\n// resets the nodes adjacency list to an empty map\nexport const mergeEdges = edges => (...alt) => alt.reduce(mergeEdgesBin, edges);\n\n// **addNeighbor** `::  Map<edge> -> ...{node:adjacency} -> Map<edge>`\n// resets the nodes adjacency list to an empty map\nexport const addNeighbor = edges => src => (n, w = 0) =>\naddBinMap(adj(edges)(src), [ n, w ]);\n\n// **addEntry** `::  Map<{node:Number}> ->  [node, Number]  -> Map<edge>`\n// resets the nodes adjacency list to an empty map\nexport const addEntry = nabes => ([ n, w = 0 ]) => addBinMap(nabes, [ n, w ]);\n","import { addMap, asMap, asSet, first, flatten, flattenBin, isIterable,\n   removeBin, spread, } from 'fenugreek-collections';\nimport { adj, copy, mergeEdges, neighbors, nodes, removeNodes, } from './graph';\nimport * as reducers from './reducers';\n\nexport const autoSpread = el =>\nisIterable(el) ? (spread(el).reduce(flattenBin, []).map(autoSpread)) : el;\n\nexport const superNode = src => nb => asSet([ src, nb ]);\n\nexport const combineNeighbors = g => src => nb =>\n  asSet(flatten(neighbors(g)(src))(neighbors(g)(nb)));\n\nexport const combineAdj = g => src => nb =>\n  asMap(flatten(adj(g)(src))(adj(g)(nb)));\n\nexport const superAdj = g => src => nb =>\n [ src, nb ].reduce(removeBin, combineAdj(g)(src)(nb));\n\nexport const superEdge = g => src => nb =>\n  addMap()(superNode(src)(nb))(superAdj(g)(src)(nb));\n\nexport const contract = g => src => (nb = first(neighbors(g)(src))) =>\nnb ? mergeEdges(removeNodes(g)(src, nb))(superEdge(g)(src)(nb)) : g;\n\nexport const contractBin = (g, [ src, nb ]) => contract(g)(src)(nb);\n\nexport const contractSrc = g => src =>\nreducers.neighborPairs(g)(src).reduce(contractBin, copy(g));\n\nexport const contractNext = (g, n = (first(nodes(g)))) =>\n  contract(copy(g))(n)();\n\nexport const contractAuto = g => nodes(g).reduce(contractNext, g);\nexport const contractMin = (g, min = 2) =>\n g.size > min ? contractMin(contractNext(g), min) : copy(g);\n","import { addMap, lastK, } from 'fenugreek-collections';\n\n// **pathEntry** `:: ( node, Number, Number ) -> {pred, length, weight}`\n// returns an object with pred, weight, and length properties\nexport const pathEntry = (pred = null, length = 1, weight = 0) => ({ pred, length, weight });\nconst pathVal = (pred = null) => (length = 1) => (weight = 0) =>\n  ({ pred, length, weight });\n  \n// **addSrc** `:: Map<pathEntry> -> node ->  Map<pathEntry>`\n// adds a {node:{pred, weight, length}} entry to a  path\nexport const appendPath = path => src => addMap(path)(src)(pathEntry(lastK(path), 1, 0));\n\n// **initPath** `:: node -> Map<pathEntry>`\n// initializes a new path given a source node\nexport const initPath = node => appendPath()(node);\n\n// **getWeight** `:: {weight:Number} -> Number`\n// returns an object with pred, weight, and length properties\nexport const getWeight = ({ weight = 0 }) => weight;\n\n// **getLength** `:: {length:Number} -> Number`\n// returns an object with pred, weight, and length properties\nexport const getLength = ({ length = 1 }) => length;\n\n// **lastVal** `:: Map<pathEntry> -> {pred, length, weight}`\n// returns the last entry in the path\nexport const lastVal = path => path.get(lastK(path));\n\n// **lastWeight** `:: Map<pathEntry> -> Number`\n// returns the last weight in the path\nexport const lastWeight = path => getWeight(lastVal(path));\n\n// **lastLength** `:: Map<pathEntry> -> Number`\n// returns the last length in the path\nexport const lastLength = path => getLength(lastVal(path));\n\n// **nextWeight** `:: Map<pathEntry> -> Number -> Number`\n// returns an object with pred, weight, and length properties\nexport const nextWeight = path => (w = 0) => lastWeight(path) + w;\n\n// **nextLength** `:: Map<pathEntry> -> Number -> Number`\n// returns an object with pred, weight, and length properties\nexport const nextLength = path => lastLength(path) ? lastLength(path) + 1 : 1;\n\n// **nextPath** `:: (Map<pathEntry>, [node, Number]) -> Map<pathEntry> `\n// returns an object with pred, weight, and length properties\nexport const nextPath = (path = new Map, [ n, w = 0 ]) =>\n  path.set(n, pathVal(lastK(path))(nextLength(path))(nextWeight(path)(w)));\n","import { addBinSet, asSet, get, hasK, lastK, mapDiff, popFirst, spread, spreadK, } from 'fenugreek-collections';\nimport { initPath, nextPath, } from './path';\nimport { components, } from './components';\n\n// **dfs** `:: Map<edge> -> node -> Map<pathEntry>`\n// depth first traversal\nexport const dfs = edges => (src) => {\n  // >**dfs.trav** `:: Map<pathEntry> -> [node, w] -> Map<pathEntry>`\n  // >depth first traversal\n  const trav = (path = initPath(src), [ n, w ] = [ lastK(path), 0 ]) =>\n    spread(mapDiff(edges.get(n))(path)).reduce(trav, nextPath(path, [ n, w ]));\n  \n  return trav(initPath(src));\n};\n\n// **bfs** `:: Map<edge> -> node -> Map<pathEntry>`\n// breadth first traversal\nexport const bfs = edges => (iNode) => {\n  const bVisit = bPath => (bQueue) => {\n    const pred = popFirst(bQueue);\n    const nextNabes = mapDiff(edges.get(pred))(bPath);\n    \n    spread(nextNabes).reduce(nextPath, bPath);\n    spreadK(nextNabes).reduce(addBinSet, bQueue);\n    return bQueue.size > 0 ? bVisit(bPath)(bQueue) : bPath;\n  };\n  \n  return bVisit(initPath(iNode))(asSet([ iNode ]));\n};\n\n// **dijkstra** `:: Map<edge> -> node -> Map<pathEntry>`\n// finds shortest paths from a source node to all node reachable from that node\nexport const dijkstra = edges => (iNode) => {\n  const reachables = bfs(edges)(iNode);\n  const inspectQueue = asSet([ iNode ]);\n  const solutionSet = initPath(iNode);\n  \n  while (inspectQueue.size > 0) {\n    const pred = popFirst(inspectQueue);\n    const nextNabes = edges.get(pred);\n    const { length: dCount, weight: dWeight } = solutionSet.get(pred);\n    \n    for (const [ nabe, nWeight ] of nextNabes) {\n      const prevMap = reachables.get(nabe) || { length: 1, weight: 0 };\n      const { length: rCount, weight: rWeight } = prevMap;\n      const dMap = { pred, length: dCount + 1, weight: dWeight + nWeight, };\n      const sMap = ((dWeight + nWeight) < rWeight) ? dMap : prevMap;\n      \n      if (!solutionSet.has(nabe)) {\n        inspectQueue.add(nabe);\n        solutionSet.set(nabe, sMap);\n      }\n    }\n  }\n  return solutionSet;\n};\n\n// **pathBetween** `:: Map<edge> -> node -> node -> Boolean`\n// checks for a path between two nodes\nexport const pathBetween = e => n0 => n1 => hasK(get(components(e))(n0))(n1);\n","import { last, spread, spreadK, spreadKV, spreadV, } from 'fenugreek-collections';\n\nexport const redStr = (str = ' ', val, id, coll) =>\n  val === last(coll) ? str.concat(val, ' ') : str.concat(val, ' , ');\nexport const collString = coll => spread(coll).reduce(redStr, '');\nexport const kString = coll => spreadK(coll).reduce(redStr, '');\nexport const vString = coll => spreadV(coll).reduce(redStr, '');\nexport const kvString = coll => spreadKV(coll).reduce(redStr, '');\n\nexport const pathString = path => ` { ${spreadK(path).join(' => ')} }`;\nexport const edgeString = ([src, nbs]) => `{ Edge ${src} >> [ ${kString(nbs)} ] } `;\n\nexport const componentString = ([node, nbs]) =>\n  `{ component ${node} >> [ ${kString(nbs)} ] } `;\n\nexport const graphString = edges =>\n  spreadKV(edges).reduce((str, [node, nabes], id) =>\n    str + edgeString([node, nabes]),\n    'Showing Edges\\n');\n\nexport const showGraph = ({ edges }) => (graphString(edges));\n"],"names":["components","edges","trav","comp","Set","node","diff","spreadK","get","reduce","addSet","visitMap","mMap","Map","map","tuple","addBinMap","componentSet","spreadV","resetNodeBin","src","addMap","asMap","addNodeBin","neighborPairs","append","addEdgeBin","nb","wt","removeEdgeBin","removeMap","disconnectNodeBin","importEdgeBin","nbs","spread","mapDiff","flatTuple","mergeEdgesBin","alts","mergeNeighbors","uniteMap","graph","elems","nodes","copy","adj","neighbors","contains","hasK","isAdjacent","addNodes","srcs","resetNodes","addEdges","w","nabes","triple","removeEdges","disconnectNodes","removeNodes","removeBin","mergeEdges","alt","addNeighbor","n","addEntry","autoSpread","isIterable","el","flattenBin","superNode","asSet","combineNeighbors","flatten","g","combineAdj","superAdj","superEdge","contract","first","contractBin","contractSrc","reducers","contractNext","contractAuto","contractMin","min","size","pathEntry","pred","length","weight","pathVal","appendPath","path","lastK","initPath","getWeight","getLength","lastVal","lastWeight","lastLength","nextWeight","nextLength","nextPath","set","dfs","bfs","iNode","bVisit","bQueue","popFirst","nextNabes","bPath","addBinSet","dijkstra","reachables","inspectQueue","solutionSet","dCount","dWeight","nabe","nWeight","prevMap","rWeight","dMap","sMap","has","add","pathBetween","e","n0","n1","redStr","str","val","coll","last","concat","collString","kString","vString","kvString","spreadKV","pathString","join","edgeString","componentString","graphString","id","showGraph"],"mappings":"8HAKaA,WAAa,SAACC,MACnBC,GAAO,QAAPA,QAAQC,0DAAO,GAAIC,KAAKC,qBAC3BC,2BAAKC,6BAAQN,EAAMO,IAAIH,KAAQF,GAAMM,OAAOP,EAAMQ,4BAAOP,GAAME,KAE5DM,EAAW,cAACC,0DAAO,GAAIC,KAAKR,qBAC/BC,2BAAKJ,EAAK,GAAIE,KAAKC,IAAOO,GAAME,IAAIC,2BAAMb,EAAK,GAAIE,KAAKC,KACrDI,OAAOO,+BAAWJ,UAEjBL,8BAAQN,GAAOQ,OAAOE,EAAU,GAAIE,OAKhCI,aAAe,kBAAS,IAAIb,KAAIc,6BAAQlB,WAAWC,sgBCbnDkB,aAAe,SAAClB,EAAOmB,SAAQC,6BAAOpB,GAAOmB,GAAKE,+BAIlDC,WAAa,SAACtB,EAAOmB,SAAQC,6BAAOpB,GAAOmB,GAAKE,2BAAMd,yBAAIP,GAAOmB,MAIjEI,cAAgB,kBAAS,mBACpCjB,8BAAQC,yBAAIP,GAAOmB,IAAMN,IAAIW,4BAAOL,MAIzBM,WAAa,SAACzB,8BAASmB,OAAKO,cAAIC,aAAK,YAC9CR,EAAKC,4BAAOb,yBAAIP,GAAOmB,IAAMO,GAAIC,KACjCD,EAAIN,4BAAOb,yBAAIP,GAAO0B,IAAKP,GAAKQ,KAAQnB,OAAOO,+BAAWM,2BAAMrB,KAIvD4B,cAAgB,SAAC5B,8BAASmB,OAAKO,eACxCP,EAAKU,+BAAUtB,yBAAIP,GAAOmB,IAAMO,KAChCA,EAAIG,+BAAUtB,yBAAIP,GAAO0B,IAAKP,KAAQX,OAAOO,+BAAWM,2BAAMrB,KAIrD8B,kBAAoB,SAAC9B,EAAOmB,SACvCI,eAAcvB,GAAOmB,GAAKX,OAAOoB,cAAeP,2BAAMrB,KAS3C+B,cAAgB,SAAC/B,8BAASmB,OAAKa,aAC5CC,6BAAOC,6BAAQF,GAAKzB,yBAAIP,GAAOmB,KAAON,IAAIsB,+BAAUhB,IACjDX,OAAOiB,WAAYH,WAAWtB,EAAOmB,KAI3BiB,cAAgB,SAACpC,EAAOqC,SACpCJ,6BAAOZ,2BAAMgB,IAAO7B,OAAOuB,cAAe/B,ICzC9BsC,eAAiBC,8BAIjBC,MAAQ,sCAAIC,+CAAUA,GAAMjC,OAAOc,WAAY,GAAIV,OAInD8B,MAAQ,kBAASpC,8BAAQe,2BAAMrB,KAI/B2C,KAAO,kBAASD,OAAM1C,GAAOQ,OAAOc,WAAYD,2BAAMrB,KAItD4C,IAAM,kBAAS,mBAAOvB,4BAAMd,yBAAIP,GAAOmB,MAIvC0B,UAAY,kBAAS,mBAAOH,OAAME,IAAI5C,GAAOmB,MAI7C2B,SAAW,kBAAS,mBAAQC,2BAAK/C,GAAOI,KAIxC4C,WAAa,kBAAS,mBAAO,mBAAMF,UAASF,IAAI5C,GAAOmB,IAAMO,MAI7DuB,SAAW,kBAAS,uCAAIC,+CAASA,GAAK1C,OAAOc,WAAYtB,KAIzDmD,WAAa,kBAAS,uCAAIhC,+CAAQA,GAAIX,OAAOU,aAAclB,KAI3DoD,SAAW,kBAAS,UAACjC,MAAKkC,0DAAI,QAAM,uCAAIC,+CACrDA,GAAMzC,IAAI0C,4BAAOF,GAAGlC,IAAMX,OAAOiB,WAAYzB,MAIhCwD,YAAc,kBAAS,mBAAO,uCAAIF,+CAC/CA,GAAMzC,IAAIC,2BAAMK,IAAMX,OAAOoB,cAAe5B,MAI/ByD,gBAAkB,kBAAS,uCAAIP,+CAC3CA,GAAK1C,OAAOsB,kBAAmBa,KAAK3C,MAIxB0D,YAAc,kBAAS,uCAAIR,+CACxCA,GAAK1C,OAAOmD,+BAAWF,gBAAgBzD,gBAAUkD,MAIpCU,WAAa,kBAAS,uCAAIC,+CAAQA,GAAIrD,OAAO4B,cAAepC,KAI5D8D,YAAc,kBAAS,mBAAO,UAACC,MAAGV,0DAAI,QACnDtC,gCAAU6B,IAAI5C,GAAOmB,IAAQ4C,EAAGV,OAInBW,SAAW,kBAAS,sCAAGD,cAAGV,aAAI,UAAQtC,gCAAUuC,GAASS,EAAGV,6WCtE5DY,WAAa,QAAbA,YACbC,iCAAWC,GAAOlC,4BAAOkC,GAAI3D,OAAO4D,oCAAgBvD,IAAIoD,GAAeE,GAE1DE,UAAY,kBAAO,mBAAMC,6BAAQnD,EAAKO,MAEtC6C,iBAAmB,kBAAK,mBAAO,mBAC1CD,4BAAME,6BAAQ3B,UAAU4B,GAAGtD,IAAM0B,UAAU4B,GAAG/C,QAEnCgD,WAAa,kBAAK,mBAAO,mBACpCrD,4BAAMmD,6BAAQ5B,IAAI6B,GAAGtD,IAAMyB,IAAI6B,GAAG/C,QAEvBiD,SAAW,kBAAK,mBAAO,oBACjCxD,EAAKO,GAAKlB,OAAOmD,+BAAWe,WAAWD,GAAGtD,GAAKO,OAErCkD,UAAY,kBAAK,mBAAO,mBACnCxD,+BAASiD,UAAUlD,GAAKO,IAAKiD,SAASF,GAAGtD,GAAKO,OAEnCmD,SAAW,kBAAK,mBAAO,eAACnD,0DAAKoD,2BAAMjC,UAAU4B,GAAGtD,UAC7DO,GAAKkC,WAAWF,YAAYe,GAAGtD,EAAKO,IAAKkD,UAAUH,GAAGtD,GAAKO,IAAO+C,KAErDM,YAAc,SAACN,8BAAKtD,OAAKO,aAASmD,UAASJ,GAAGtD,GAAKO,IAEnDsD,YAAc,kBAAK,mBAChCC,eAAuBR,GAAGtD,GAAKX,OAAOuE,YAAapC,KAAK8B,MAE3CS,aAAe,SAACT,MAAGV,0DAAKe,2BAAMpC,MAAM+B,UAC/CI,UAASlC,KAAK8B,IAAIV,MAEPoB,aAAe,kBAAKzC,OAAM+B,GAAGjE,OAAO0E,aAAcT,IAClDW,YAAc,QAAdA,GAAeX,MAAGY,0DAAM,QACpCZ,GAAEa,KAAOD,EAAMD,EAAYF,aAAaT,GAAIY,GAAO1C,KAAK8B,sTC/B5Cc,UAAY,cAACC,0DAAO,KAAMC,yDAAS,EAAGC,yDAAS,SAASF,OAAMC,SAAQC,WAC7EC,QAAU,cAACH,0DAAO,WAAS,eAACC,0DAAS,QAAM,eAACC,0DAAS,SACtDF,OAAMC,SAAQC,aAINE,WAAa,kBAAQ,mBAAOxE,6BAAOyE,GAAM1E,GAAKoE,UAAUO,2BAAMD,GAAO,EAAG,MAIxEE,SAAW,kBAAQH,cAAaxF,IAIhC4F,UAAY,oBAAGN,OAAAA,aAAS,UAAQA,IAIhCO,UAAY,oBAAGR,OAAAA,aAAS,UAAQA,IAIhCS,QAAU,kBAAQL,GAAKtF,IAAIuF,2BAAMD,KAIjCM,WAAa,kBAAQH,WAAUE,QAAQL,KAIvCO,WAAa,kBAAQH,WAAUC,QAAQL,KAIvCQ,WAAa,kBAAQ,eAAChD,0DAAI,QAAM8C,YAAWN,GAAQxC,IAInDiD,WAAa,kBAAQF,YAAWP,GAAQO,WAAWP,GAAQ,EAAI,GAI/DU,SAAW,cAACV,0DAAO,GAAIjF,yCAAOmD,cAAGV,aAAI,UAChDwC,GAAKW,IAAIzC,EAAG4B,QAAQG,2BAAMD,IAAOS,WAAWT,IAAOQ,WAAWR,GAAMxC,0PCzCzDoD,IAAM,kBAAS,UAACtF,MAGrBlB,GAAO,QAAPA,QAAQ4F,0DAAOE,SAAS5E,6DAAmB2E,2BAAMD,GAAO,wBAAxB9B,OAAGV,aACvCpB,6BAAOC,6BAAQlC,EAAMO,IAAIwD,IAAI8B,IAAOrF,OAAOP,EAAMsG,SAASV,GAAQ9B,EAAGV,YAEhEpD,GAAK8F,SAAS5E,MAKVuF,IAAM,kBAAS,UAACC,MACrBC,GAAS,QAATA,YAAkB,UAACC,MACjBrB,GAAOsB,8BAASD,GAChBE,EAAY7E,6BAAQlC,EAAMO,IAAIiF,IAAOwB,sCAEpCD,GAAWvG,OAAO+F,SAAUS,gCAC3BD,GAAWvG,OAAOyG,+BAAWJ,GAC9BA,EAAOvB,KAAO,EAAIsB,EAAOI,GAAOH,GAAUG,UAG5CJ,GAAOb,SAASY,IAAQrC,4BAAQqC,OAK5BO,SAAW,kBAAS,UAACP,UAC1BQ,GAAaT,IAAI1G,GAAO2G,GACxBS,EAAe9C,4BAAQqC,IACvBU,EAActB,SAASY,GAEtBS,EAAa9B,KAAO,GAAG,IACtBE,GAAOsB,8BAASM,GAChBL,EAAY/G,EAAMO,IAAIiF,KACgB6B,EAAY9G,IAAIiF,GAA5C8B,IAAR7B,OAAwB8B,IAAR7B,0CAEQqB,iDAAW,gCAA9BS,OAAMC,OACXC,EAAUP,EAAW5G,IAAIiH,KAAW/B,OAAQ,EAAGC,OAAQ,GAC7BiC,GAAYD,EAApCjC,OAAoCiC,EAApBhC,QAClBkC,GAASpC,OAAMC,OAAQ6B,EAAS,EAAG5B,OAAQ6B,EAAUE,GACrDI,EAASN,EAAUE,EAAWE,EAAWC,EAAOF,CAEjDL,GAAYS,IAAIN,OACNO,IAAIP,KACLhB,IAAIgB,EAAMK,yFAIrBR,KAKIW,YAAc,kBAAK,mBAAM,mBAAMjF,2BAAKxC,yBAAIR,WAAWkI,IAAIC,IAAKC,wFCzD5DC,OAAS,cAACC,0DAAM,IAAKC,eAASC,oCACzCD,KAAQE,0BAAKD,GAAQF,EAAII,OAAOH,EAAK,KAAOD,EAAII,OAAOH,EAAK,QACjDI,WAAa,kBAAQzG,6BAAOsG,GAAM/H,OAAO4H,OAAQ,KACjDO,QAAU,kBAAQrI,8BAAQiI,GAAM/H,OAAO4H,OAAQ,KAC/CQ,QAAU,kBAAQ3H,8BAAQsH,GAAM/H,OAAO4H,OAAQ,KAC/CS,SAAW,kBAAQC,+BAASP,GAAM/H,OAAO4H,OAAQ,KAEjDW,WAAa,wBAAczI,6BAAQuF,GAAMmD,KAAK,cAC9CC,WAAa,qCAAE9H,OAAKa,uBAAmBb,WAAYwH,QAAQ3G,YAE3DkH,gBAAkB,qCAAE9I,OAAM4B,4BACtB5B,WAAauI,QAAQ3G,YAEzBmH,YAAc,kBACzBL,+BAAS9I,GAAOQ,OAAO,SAAC6H,IAAoBe,4BAAdhJ,OAAMkD,aAClC+E,GAAMY,YAAY7I,EAAMkD,KACxB,oBAES+F,UAAY,eAAGrJ,KAAAA,YAAamJ,aAAYnJ"}